<?php

declare(strict_types=1);

namespace Tbessenreither\MultiLevelCache\CachedServiceGenerator\Service;

use Tbessenreither\MultiLevelCache\CachedServiceGenerator\Attribute\MlcCachableMethod;
use Tbessenreither\MultiLevelCache\CachedServiceGenerator\Attribute\MlcCachableService;
use Tbessenreither\MultiLevelCache\CachedServiceGenerator\Attribute\MlcCachedService;
use Tbessenreither\MultiLevelCache\CachedServiceGenerator\Exception\MlcUpdateCachedServiceException;
use ReflectionClass;
use ReflectionMethod;
use ReflectionNamedType;
use RuntimeException;
use Throwable;

class MlcMakeCachedServiceService
{
    public const DEFAULT_TTL_SECONDS = 3600;

    public function __construct(
    ) {
    }

    /**
     * @return array<{interface: string, class: string}>
     */
    public function generateCachedService(string $class, ?string $cachedClass = null): array
    {
        $reflection = new ReflectionClass($class);

        $classDotSeparated = str_replace('\\', '.', $class);

        $attribute = $reflection->getAttributes(MlcCachedService::class);
        if (!empty($attribute)) {
            throw new RuntimeException("The class '$class' is already a cached service.");
        }

        $namespace = $reflection->getNamespaceName();
        $shortName = $reflection->getShortName();

        if($cachedClass === null) {
            $cachedClassName = $shortName . 'Cached';
            $cachedClass = $namespace . '\\' . $cachedClassName;
        } else {
            $cachedClassName = $cachedClass;
            if(str_contains($cachedClass, '\\')) {
                //fully qualified class name
                $parts = explode('\\', $cachedClass);
                $cachedClassName = array_pop($parts);
            }
        }

        $this->checkOriginalClass($class);
        $this->checkCachedClass($cachedClass);

        $methods = $this->getPublicMethods($reflection);

        $defaultTtl = $this->getDefaultTtlFromOriginalClassReflection($reflection);

        $dynamicMethods = $this->generateDynamicMethodsCode($methods);

        $rootInfo = MlcFileOperationService::findRootForClass($class);

        $interfaceRootNamespace = $rootInfo['namespace'].'Interface\\';
        $interfaceRelativeNamespace = str_replace(
            $rootInfo['namespace'],
            '',
            $namespace
        );
        $interfaceNamespace = $interfaceRootNamespace.$interfaceRelativeNamespace;
        $interfaceClassName = $shortName . 'Interface';
        $interfaceClass = $interfaceNamespace . '\\' . $interfaceClassName;

        $interfaceCode = MlcRenderTemplateService::render('Interface/InterfaceWrapper', [
            'InterfaceNamespace' => $interfaceNamespace,
            'ServiceName' => $shortName,
            'DynamicInterfaceSignatures' => $dynamicMethods['interfaces'],
        ]);

        $generatedFiles = [];

        $generatedFiles['interface'] = MlcFileOperationService::writeFile(
            originalClass: $class,
            class: $interfaceClass,
            code: $interfaceCode
        );

        $classCode = MlcRenderTemplateService::render('Class/CachedService', [
            'ServiceNamespace' => $namespace,
            'ServiceName' => $shortName,
            'classDotSeparated' => $classDotSeparated,
            'InterfaceClass' => $interfaceClass,
            'InterfaceClassName' => $interfaceClassName,
            'DefaultTtlSeconds' => $defaultTtl,
            'DynamicMethods' => $dynamicMethods['methods'],
        ]);

        $generatedFiles['class'] = MlcFileOperationService::writeFile(
            originalClass: $class,
            class: $cachedClass,
            code: $classCode,
        );

        MlcFileOperationService::addInterfaceToClass(
            class: $class,
            interface: $interfaceClass,
        );

        return $generatedFiles;
    }

    /**
     *
     * Updates all cached services that are marked as autogenerated.
     * @return array<array{service: string, status: string, message: string}>
     */
    public function updateAllCachedServices(): array
    {
        $updatedServices = [];
        foreach (MlcFetchAllCachedServices::getAllAutogeneratedServices() as $serviceData) {
            try {
                $serviceName = $serviceData['serviceName'];

                $getOriginalClass = $serviceData['cachedServiceAttr']->getOriginalServiceClass();
                $this->generateCachedService(
                    class: $getOriginalClass,
                    cachedClass: $serviceData['reflection']->getName(),
                );

                $updatedServices[] = [
                    'service' => $serviceName,
                    'status' => 'updated',
                    'message' => '',
                ];
            } catch(MlcUpdateCachedServiceException $e) {
                $updatedServices[] = [
                    'service' => $serviceName,
                    'status' => $e->getStatus(),
                    'message' => $e->getMessage(),
                ];
            } catch(Throwable $e) {
                $updatedServices[] = [
                    'service' => $serviceName,
                    'status' => 'error',
                    'message' => $e->getMessage(),
                ];
            }
        }
        return $updatedServices;
    }

    /**
     * Generate PHP code for all dynamic methods.
     * @return array{methods: string, interfaces: string}
     */
    private function generateDynamicMethodsCode(array $classMethods): array
    {
        // Get all public methods from the original service class
        $serviceClass = $classMethods ? $classMethods[0]->getDeclaringClass()->getName() : null;
        $serviceClassShort = $classMethods ? $classMethods[0]->getDeclaringClass()->getShortName() : null;
        if (!$serviceClass) {
            throw new RuntimeException("Could not determine service class from methods.");
        }

        $methods = [];
        $interfaceSignatures = [];

        $methodDoc = false;
        foreach ($classMethods as $method) {
            $name = $method->getName();
            // Filter out all magic methods (names starting with '__')
            if ($method->isConstructor() || str_starts_with($name, '__')) {
                continue;
            }
            $params = [];
            $args = [];
            foreach ($method->getParameters() as $param) {
                $paramStr = '';
                if ($param->hasType()) {
                    $type = $param->getType();
                    if ($type instanceof ReflectionNamedType) {
                        $paramStr .= $this->fixInlinedClassNames($type->getName()) . ' ';
                    }
                }
                $paramStr .= '$' . $param->getName();
                if ($param->isDefaultValueAvailable()) {
                    $default = var_export($param->getDefaultValue(), true);
                    $paramStr .= ' = ' . $default;
                }
                $params[] = $paramStr;
                $args[] = '$' . $param->getName();
            }
            $returnType = $method->getReturnType();
            $returnTypeStr = '';
            if ($returnType && $returnType instanceof ReflectionNamedType) {
                $returnTypeStr = $this->fixInlinedClassNames($returnType->getName());
            } else {
                throw new RuntimeException("Method {$method->getName()} is missing a return type declaration. This is a requirement for cached services.");
            }
            $isVoid = $returnTypeStr === 'void';

            // Get doc comment
            $methodDocOriginal = $method->getDocComment();

            $isCached = false;
            $cacheTtl = 0;
            foreach ($method->getAttributes() as $attr) {
                if ($attr->getName() === MlcCachableMethod::class) {
                    $attributeObject = $attr->newInstance();
                    $isCached = true;
                    $cacheTtl = $attributeObject->getTtlSeconds() ?? 0;
                    $methodDoc = MlcPhpDocManipulatorService::add(
                        docComment: $methodDocOriginal,
                        linesToAdd: "cache-ttl should be {$cacheTtl} seconds. Check Attribute in ".$serviceClass." for details.",
                        position: 'description',
                    );
                    break;
                }
            }

            if($isCached && !$isVoid) {
                $templateName = 'CacheServiceCachedMethod';
            } else {
                if($method->isStatic()) {
                    $templateName = 'CacheServiceUncachedStaticMethod';
                } else {
                    $templateName = 'CacheServiceUncachedMethod';
                }
            }

            $methods[] = MlcRenderTemplateService::render('Class/' . $templateName, [
                'ServiceName' => $serviceClassShort,
                'MethodDocumentation' => MlcPhpDocManipulatorService::indent($methodDoc),
                'MethodFunctionToken' => $method->isStatic() ? 'static function' : 'function',
                'MethodName' => $method->getName(),
                'MethodNamePostfix' => $method->isStatic() ? 'Cached' : '',
                'MethodArguments' => implode(', ', $params),
                'MethodReturnType' => $returnTypeStr,
                'MethodArgumentsArray' => implode(', ', $args),
                'IsStaticBoolean' => $method->isStatic() ? 'true' : 'false',
                'MethodReturnStatement' => $returnTypeStr !== 'void' ? 'return ' : '',
            ]);

            $interfaceSignatures[] = MlcRenderTemplateService::render('Interface/Signature', [
                'ServiceName' => $serviceClassShort,
                'MethodDocumentation' => MlcPhpDocManipulatorService::indent($methodDocOriginal),
                'MethodFunctionToken' => $method->isStatic() ? 'static function' : 'function',
                'MethodName' => $method->getName(),
                'MethodArguments' => implode(', ', $params),
                'MethodReturnType' => $returnTypeStr,
                'MethodArgumentsArray' => implode(', ', $args),
                'MethodReturnStatement' => $returnTypeStr !== 'void' ? 'return ' : '',
            ]);

            if($isCached && $method->isStatic()) {
                // For static cached methods, also generate a non-cached version

                $methodDocStatic = MlcPhpDocManipulatorService::add(
                    docComment: $methodDocOriginal,
                    linesToAdd: [
                        "WARNING: Static methods can't be cached.",
                        "This is the uncached version of the method.",
                        "",
                        "Consider using the non static {$method->getName()}Cached() method for better performance but be aware of the fact it's not available in {$serviceClassShort}."
                    ],
                    position: 'description',
                );
                $methodDocStatic = MlcPhpDocManipulatorService::add(
                    docComment: $methodDocStatic,
                    linesToAdd: [
                        "@see {$method->getName()}Cached().",
                    ],
                    position: '@',
                );
                $methods[] = MlcRenderTemplateService::render('Class/CacheServiceUncachedStaticMethod', [
                    'ServiceName' => $serviceClassShort,
                    'MethodDocumentation' => MlcPhpDocManipulatorService::indent($methodDocStatic),
                    'MethodFunctionToken' => 'static function',
                    'MethodName' => $method->getName(),
                    'MethodNamePostfix' => '',
                    'MethodArguments' => implode(', ', $params),
                    'MethodReturnType' => $returnTypeStr,
                    'MethodArgumentsArray' => implode(', ', $args),
                    'IsStaticBoolean' => 'true',
                    'MethodReturnStatement' => $returnTypeStr !== 'void' ? 'return ' : '',
                ]);
            }

        }

        $methodCode = implode("\n", $methods);
        $interfaceCode = implode("\n", $interfaceSignatures);

        return [
            'methods' => $methodCode,
            'interfaces' => $interfaceCode,
        ];
    }

    /**
     * @param ReflectionClass $reflection
     * @return array<ReflectionMethod>
     */
    private function getPublicMethods(ReflectionClass $reflection): array
    {
        $methods = [];
        foreach ($reflection->getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
            $methods[] = $method;
        }
        return $methods;
    }

    public function getDefaultTtlFromOriginalClassReflection(ReflectionClass $reflection): int
    {
        $attribute = $reflection->getAttributes(MlcCachableService::class);
        if (empty($attribute)) {
            return self::DEFAULT_TTL_SECONDS;
        }
        /**
         * @var MlcCachableService
         */
        $attributeInstance = $attribute[0]->newInstance();
        return $attributeInstance->getDefaultTtlSeconds();
    }

    private function fixInlinedClassNames(string $typeString): string
    {
        if(strpos($typeString, '\\') !== false && !in_array($typeString, ['int ', 'float ', 'string ', 'bool ', 'array ', 'callable ', 'iterable ', 'object ', 'mixed ', 'void '], true)) {
            $typeString = '\\' . $typeString;
        }
        return $typeString;
    }

    private function checkOriginalClass(string $originalClass): void
    {
        if (!class_exists($originalClass)) {
            throw new RuntimeException("Original service class '$originalClass' does not exist.");
        }
    }

    private function checkCachedClass(string $cachedClass): void
    {
        if (!class_exists($cachedClass)) {
            return;
        }

        $reflection = new ReflectionClass($cachedClass);
        $attribute = $reflection->getAttributes(MlcCachedService::class);
        if (empty($attribute)) {
            throw new RuntimeException("Cached service class '$cachedClass' is not marked with MlcCachedService attribute.");
        }

        $attributeInstance = $attribute[0]->newInstance();
        if (!class_exists($attributeInstance->getOriginalServiceClass())) {
            throw new RuntimeException("Cached service class '$cachedClass' does not reference an existing service class.");
        }

        if(!$attributeInstance->isSyncAllowed()) {
            throw new MlcUpdateCachedServiceException(
                type: 'info',
                status: 'skipped',
                message: "Cached service class '$cachedClass' is marked as user modified (syncAllowed: false).",
            );
        }
    }
}
