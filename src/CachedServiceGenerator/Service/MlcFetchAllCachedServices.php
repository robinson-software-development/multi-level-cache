<?php

declare(strict_types=1);

namespace Tbessenreither\MultiLevelCache\CachedServiceGenerator\Service;

use Tbessenreither\MultiLevelCache\CachedServiceGenerator\Attribute\MlcCachedService;
use Generator;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;
use ReflectionClass;
use RuntimeException;
use SplFileInfo;

class MlcFetchAllCachedServices
{
    private static function getSrcDir(): string
    {
        $currentDir = dirname(__DIR__);
        //remove segments until we reach "src"
        while (basename($currentDir) !== 'src') {
            $currentDir = dirname($currentDir);
        }
        return $currentDir;
    }

    /**
     * @return Generator<array{serviceName: string, reflection: ReflectionClass, cachedServiceAttr: MlcCachedService}>
     */
    public static function getAllAutogeneratedServices(): Generator
    {
        //fetch all classes that have the MlcCachedService Attribute
        $srcDir = self::getSrcDir();
        if (!is_dir($srcDir)) {
            throw new RuntimeException("Source directory '$srcDir' not found.");
        }

        $it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($srcDir));
        foreach ($it as $file) {
            /** @var SplFileInfo $file */
            if (!$file->isFile()) {
                continue;
            }

            // quick filter: only generated cached classes end with "Cached.php"
            if (!str_ends_with($file->getFilename(), '.php')) {
                continue;
            }

            $path = $file->getRealPath();
            if ($path === false) {
                continue;
            }

            $contents = file_get_contents($path);
            if ($contents === false) {
                continue;
            }

            // check for the attribute marker
            if (strpos($contents, '#[MlcCachedService') === false) {
                continue;
            }

            // extract namespace (if any)
            $namespace = '';
            if (preg_match('/^namespace\s+([^;]+);/m', $contents, $nsMatch)) {
                $namespace = trim($nsMatch[1]);
            }

            // extract the class name
            $fqcn = '';
            if (preg_match('/class\s+([A-Za-z_\x80-\xff][A-Za-z0-9_\x80-\xff]*)/m', $contents, $classMatch)) {
                $className = $classMatch[1];
                $fqcn = $namespace !== '' ? $namespace . '\\' . $className : $className;
            }

            if($fqcn === '') {
                continue;
            }


            $reflection = new ReflectionClass($fqcn);
            $attributes = $reflection->getAttributes(MlcCachedService::class);

            if(count($attributes) === 0) {
                continue;
            }
            /** @var MlcCachedService $cachedServiceAttr */
            $cachedServiceAttr = $attributes[0]->newInstance();

            yield [
                'serviceName' => $fqcn,
                'reflection' => $reflection,
                'cachedServiceAttr' => $cachedServiceAttr,
            ];
        }
    }
}
